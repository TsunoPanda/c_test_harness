'''
 This module provides class which includes source files required build executable.
 The class provides the method which reads jsonc file defining source files and their attributes
 like compiler options
'''
import os
import re
import subprocess
import glob
from enum import Enum
from typing import List
from typing import Tuple
from typing import Optional
import dataclasses
import TimeStampComp
import jsonc

# Return value of 'Makefile.Make' and 'Makefile.Build'
class ExecutableStatus(Enum):
    '''
     This enumerator class provides values which suggests the executable file generated by
     MakeFile class is valid or not.
    '''
    EXECUTABLE_VALID   = 0
    EXECUTABLE_INVALID = 1

@dataclasses.dataclass
class _RelevantFiles:
    '''
        This data class represents information of a file required to be compiled
    '''
    src: str
    obj: str
    dep: str
    opt: str

class MakeFile:
    '''
     This class includes source files and their attribute like compiler options. And provides
     methods executing 'make', 'build', 'clear'.
    '''

    # Return value of 'IssueCompileCommand'
    class CompileStatus(Enum):
        '''
         This enumerator class includes values suggesting the result of the compilation of a file.
        '''
        COMPILE_SUCCEEDED = 0
        COMPILE_ERROR     = 1

    # Return value of 'LinkObjects'
    class LinkStatus(Enum):
        '''
         This enumerator class includes values suggesting the result of the linking.
        '''
        LINK_SKIPPED   = 0
        LINK_SUCCEEDED = 1
        LINK_ERROR     = 2

    # Return value of 'CompileSources'
    class WholeCompileStatus(Enum):
        '''
         This enumerator class includes values suggesting the result of the compilation as a whole.
        '''
        NO_COMPILED_FILE           = 0
        NO_COMPILE_ERROR           = 1
        AT_LEAST_ONE_COMPILE_ERROR = 2

    def __init__(self, target_path:str = '', compiler:str = '',
                    include_path_list:Optional[List[str]] = None,
                    linker_option_list:Optional[List[str]] = None):
        """
        This method initializes all global variables in this module
        """

        # Compiler to be used
        # Save the compiler command into a global variable
        self.__compiler:str = compiler

        # Target executable file path
        # Save the target file path into a global variable
        self.__target_path:str = target_path

        # Include arguments in the compiling command. This will be generated from
        # the '@gaIncludePaths'.
        # Initialize include arguments
        if include_path_list is None:
            self.__include_string:str = ''
        else:
            self.__include_string:str = self.__include_path_list_to_command(include_path_list)

        # Option arguments in the compiling command. This will be generated from the '@gaOptions'.
        if linker_option_list is None:
            self.__linker_option_string:str = ''
        else:
            self.__linker_option_string:str = self.__option_list_to_command(linker_option_list)

        # This is an array of RelevantFiles
        # the respective values are 'source file path', 'object file path', 'dependency
        # file path', 'option string'
        # for all sources files to be compiled.
        self.__all_relevant_file_list:List[_RelevantFiles] = []

    @staticmethod
    def __std_output(msg:str):
        print(msg)

    @staticmethod
    def __option_list_to_command(option_list:List[str])->str:
        """
        This function converts the array of the options into the string
        which can be used in the command.
        e.g. ["-Wall", "-O2", "-MMD"] -> "-Wall -O2 -MMD"
        """

        # Combine the members of the list with separator ' '.
        return ' '.join(option_list)

    def __include_path_list_to_command(self, include_path:List[str])->str:
        """
        This function converts the array of the include paths into the string which can
        be used in the command.
        e.g. ["../ProductCode/SetAndGet/", "./TestHarness/"] ->
        "-I ../ProductCode/SetAndGet/ -I ./TestHarness/"
        """

        # Make the array which will have include options as members.
        # e.g ["../ProductCode/SetAndGet/", "./TestHarness/"]
        #  -> ["-I ../ProductCode/SetAndGet/", "-I ./TestHarness/"]
        include_option_list = list(map(lambda s: '-I ' + s, include_path))

        # Get the option string by inputting the option array to 'OptionArrayToCommand',
        # and return the result.
        return self.__option_list_to_command(include_option_list)

    @staticmethod
    def __check_source_file_extention(file_path:str)->Tuple[bool, str]:
        basename = os.path.basename(file_path)
        filename, ext = os.path.splitext(basename)
        if ext in ('.c', '.cpp'):
            return (True, filename)
        return (False, filename)

    @staticmethod
    def __create_object_folder(obj_path:str):
        """
        This function creates the folder where all object files to be generated will be saved.
        $objPath: Path to a folder where all object files are stored
        """

        # Save the object file path temporarily.
        obj_tmp = obj_path

        # Replace '/' into '\'. This is required for the windows shell.
        obj_tmp = re.sub('/', r'\\', obj_tmp)

        # If NOT the object folder exists, then, make it.
        subprocess.check_output('if not exist '+ obj_tmp + ' mkdir ' + obj_tmp, shell=True)

    def __issue_compile_command(self, c_compiler:str, include_string:str,
                                    relevant_files:_RelevantFiles)->CompileStatus:
        """
        This function issues the compiling command according to the input parameters.
        This also displays the command and the output result.
        If this function detected 'error' in the output message of the command,
        it returns 'COMPILE_ERROR'. Unless, returns 'COMPILE_SUCCEEDED'.
        cCompiler: Compiler command e.g. 'gcc'
        includeStr: Include string e.g. '-I ./hoge/'
        dRelevantFile: Reference to a hash which has source, object, dependency file path
        """

        option_string = relevant_files.opt

        # Make compiling command
        compile_cmd =(
            f'{c_compiler} {option_string} {include_string}'
            f' -c {relevant_files.src} -o {relevant_files.obj}'
        )

        # Display the command.
        self.__std_output(compile_cmd)

        # Execute the command and get the STDOUT.
        # Execute the command and get the output as binary
        try:
            whole_mssage_byte = subprocess.check_output(compile_cmd,
                                                   stderr=subprocess.STDOUT,
                                                   shell=True)
        except subprocess.CalledProcessError as exception:
            self.__std_output(exception.output.decode())
            return self.CompileStatus.COMPILE_ERROR

        # Convert the binary into string
        whole_message = whole_mssage_byte.decode()

        # Display the result.
        if not whole_message == '':
            self.__std_output(whole_message)

        # No error message detected.
        return self.CompileStatus.COMPILE_SUCCEEDED

    def __does_the_file_need_to_be_compiled(self, relevant_file:_RelevantFiles)->bool:
        """
        This function check if the input file needs to be compiled or it does not.
        Return TRUE: If input file needs to be compiled.
        Return FALSE: If input file dose not need to be compiled.
        hRelevantFile_ref: Reference to a hash which has source, object, dependency file path
        """

        # Get the object file path from the hash
        object_file     = relevant_file.obj

        # Get the dependency file path from the hash
        dependency_file = relevant_file.dep

        # Are both the object/dependency files exist?
        if os.path.exists(object_file) and os.path.exists(dependency_file):
            # Get the array which contains all the relational files to the source file.
            related_file_list = self.__get_related_file_list(dependency_file)

            # Is the object files newest compared to all the relative files?
            if TimeStampComp.IsTheFileLatest(object_file, related_file_list) is True:
                # Yes, the object file is up-to-date, skip the compiling.
                return False
            # One of the relative file is updated. Compile the source file.
            return True
        # One of the object/dependency files does not exist.
        # Then, compile the file.
        return True

    @staticmethod
    def __get_directry(file_path:str)->str:
        return os.path.dirname(file_path)


    def __compile_sources(self, compiler:str, include_path:str)->WholeCompileStatus:
        """
        This function compile all the source files listed in the global array 'gaAllRelevantFiles'.
        If the object file is already exist and it is the latest, this skips the compilation.
        Returns NO_COMPILE_ERROR: If compilation finished without error.
        Returns AT_LEAST_ONE_COMPILE_ERROR: If at least one file finished with an error.
        Returns NO_COMPILED_FILE: If no file has been compiled.
        compiler: Compiler command e.g. 'gcc'
        aAllRelevantFiles_ref: Reference to the array which will contains all source, object,
        dependency file paths.
        includeStr: Include string e.g. '-I ./hoge/'
        """

        # Initialize the compile error indicator.
        # This value will be TRUE if at least one compile error happened.
        is_compile_error:bool = False

        # Initialize the file compile indicator.
        # This value will be TRUE if at least one file was compiled.
        does_compiled_file_exist:bool = False

        # Start compiling for all source files in the array
        for relative_files in self.__all_relevant_file_list:
            # If the source file does NOT exists
            if os.path.exists(relative_files.src) is False:
                # The source file was not found
                self.__std_output("Error: Could not find " + relative_files.src)

                # Error detected, set the error indicator 'TRUE'
                is_compile_error = True

            # Check if the source file needs to be compiled
            elif self.__does_the_file_need_to_be_compiled(relative_files) is True:
                # The file need to be compiled

                # Capture object file folder path
                obj_path = self.__get_directry(relative_files.obj)

                # If not exists, Create a folder where all object files will be stored.
                self.__create_object_folder(obj_path)

                # Set the compile indicator 'TRUE'
                does_compiled_file_exist = True

                # Issue the compile command and check if it outputs error.
                if (self.__issue_compile_command(compiler, include_path, relative_files) ==
                    self.CompileStatus.COMPILE_ERROR):
                    # Error detected, set the error indicator 'TRUE'
                    is_compile_error = True

            else:
                # The source file does not need to be compiled. skip.
                self.__std_output('skip compiling ' + relative_files.obj)

        # Check the Compiling result
        # Error exists?
        if is_compile_error is True:
            # Error has happened
            return self.WholeCompileStatus.AT_LEAST_ONE_COMPILE_ERROR

        # Compiled file exist?
        if does_compiled_file_exist is True:
            # Some files are compiled without any errors
            return self.WholeCompileStatus.NO_COMPILE_ERROR
        # No files has been compiled.
        return self.WholeCompileStatus.NO_COMPILED_FILE

    def __link_objects(self, compiler:str, option_string:str, target:str)->LinkStatus:
        """
        This function links all the object files listed in the global array 'gaAllRelevantFiles'.
        And generates target executable file.
        compiler: Compiler command e.g. 'gcc'
        aAllRelevantFiles_ref: Reference to the array which will contains all source, object,
        dependency file paths.
        option_string: Option string e.g. '-Wall -O'
        targetStr:
        """

        # Define/initialize the string which will contain all object file to be linked.
        all_object = ''

        # Append all object files in the array
        for relevant_file in self.__all_relevant_file_list:
            all_object = all_object + relevant_file.obj + ' '

        # Make the command
        cmd = f'{compiler} {option_string} -o {target} {all_object}'

        # Display the command
        self.__std_output(cmd)

        try:
            whole_mssage_byte = subprocess.check_output(cmd,
                                                   stderr=subprocess.STDOUT,
                                                   shell=True)
        except subprocess.CalledProcessError as exception:
            self.__std_output(exception.output.decode())
            return self.LinkStatus.LINK_ERROR

        # Convert the binary into string
        whole_message = whole_mssage_byte.decode()

        # Display the result.
        if not whole_message == '':
            self.__std_output(whole_message)

        # No error message detected.
        return self.LinkStatus.LINK_SUCCEEDED

    @staticmethod
    def __get_related_file_list(file_path:str)->List[str]:
        """
        This function returns the array containing all relative files found in the input .d file
        file_path: Dependency file path
        """

        # Define/initialize the array of relative file found in the input .d file
        file_list = []

        # Open the dependency file.
        with open(file_path, 'r', encoding = 'UTF-8') as in_file:

            lines = in_file.readlines()

            # Read the file line by line.
            for line in lines:
                # Clean the line string
                # Remove the object file
                line = re.sub(r'.+\:', '', line)
                # Remove '\'
                line = re.sub(r'\\', '', line)
                # Remove a space at the top.
                line = re.sub(r'^\s+', '', line)
                # Remove a space at the bottom.
                line = re.sub(r'\s+$', '', line)

                # Split the line into relevant files
                file_list += re.split(r'\s+', line)


        # Remove blank member just in case
        file_list = [file for file in file_list if file != '']

        # Return the array of the related files
        return file_list

    def __is_linking_requiered(self, target_path:str, compile_states:WholeCompileStatus)->bool:
        """
        This function returns TRUE if the linking required. Returns FALSE if not.
        target_path: Path to the target executable file
        compile_states: Compile state should be return value of the 'CompileSources'
        """

        # If at least one source file was updated and compiled without error.
        if compile_states == self.WholeCompileStatus.NO_COMPILE_ERROR:
            # Linking is required anyway.
            return True

        # If at least one error happened.
        if compile_states == self.WholeCompileStatus.AT_LEAST_ONE_COMPILE_ERROR:
            # Skip linking due to the error
            self.__std_output('Skip linking, because at least one compile error happened.')
            return False

        # If no compiled file exists
        # compile_states == self.WholeCompileStatus.NO_COMPILED_FILE
        # If the executable exists,
        if os.path.exists('./' + target_path) is True:
            # Skip linking because no updated source file, and the executable exists.
            self.__std_output('Skip linking, because nothing has been updated.')
            return False
        # No compiled file, but there isn't executable file,
        # then linking is required.
        return True

    def __is_the_executable_valid(self, compile_state:WholeCompileStatus,
                                     link_state:LinkStatus)->ExecutableStatus:
        """
        This function decides if there is valid executable generated as
        seeing the compilation state and linking state.
        compile_state: Previous Compilation state
        link_state: Previous linking state
        """

        # Check the compilation state
        if compile_state == self.WholeCompileStatus.AT_LEAST_ONE_COMPILE_ERROR:
            # Compile failed, then no valid executable anyway
            return ExecutableStatus.EXECUTABLE_INVALID

        # Check the linking state
        if link_state == self.LinkStatus.LINK_ERROR:
            # Linking failed, then no valid executable anyway
            return ExecutableStatus.EXECUTABLE_INVALID

        # No error, then the execute file is valid
        return ExecutableStatus.EXECUTABLE_VALID

    def add_src(self, source_file:str, options:List[str], obj_path:str)->str:
        """
        source_file:
        aOption_ref:
        obj_path:
        """

        # Make all the relevant file array for each source file
        is_c_file, file_name = self.__check_source_file_extention(source_file)
        if is_c_file is True :
            # Initialize the relevant file object
            relevant_file = _RelevantFiles(
                src = source_file,
                obj = obj_path + '/' + file_name + '.o',
                dep = obj_path + '/' + file_name + '.d',
                opt = self.__option_list_to_command(options)
                )

            # Append a instance which will contains all source, object, dependency file paths.
            # For more explanation, see where this is defined.
            self.__all_relevant_file_list.append(relevant_file)
            return relevant_file.obj

        # The input .c source file has a bad format. Display the warning message.
        self.__std_output('Warning: The way to define the c file is not correct.')
        self.__std_output('>>> ' + source_file)
        return ''

    def load_json_makefile(self, json_path):
        '''
        This method read a json file which contains source files to be compiled and
        associated compile options
        '''
        with  open(json_path, 'r', encoding = 'UTF-8') as json_file:
            makefile_dir = jsonc.load(json_file)

            # Overwrite
            if 'compiler' in makefile_dir:
                self.__compiler = makefile_dir['compiler']

            # Overwrite
            if 'target' in makefile_dir:
                self.__target_path = makefile_dir['target']

            # Overwrite
            if 'linker_option' in makefile_dir:
                self.__linker_option_string = self.__option_list_to_command(
                                                makefile_dir['linker_option']
                                            )

            # Append
            if 'include_path' in makefile_dir:
                include_str = self.__include_path_list_to_command(makefile_dir["include_path"])
                self.__include_string  += f' {include_str}'

            # Append
            obj_list = []
            if 'source_file' in makefile_dir:
                for source in makefile_dir['source_file']:
                    obj_list.append(self.add_src(source['path'], source['opt'], source['obj_dir']))

            return obj_list


    def get_all_object_path(self):
        '''
        This method return all objects to be generated if make or build would be done.
        '''
        return [relevant_file.obj for relevant_file in self.__all_relevant_file_list]

    def get_target_path(self):
        '''
        This method return the path of the target object
        '''
        return self.__target_path

    def make(self)->ExecutableStatus:
        """
        This function will make target object executable file. But only out-of-date source files
        are compiled. That is, up-to-data files will be skipped to be compiled.
        Linking is also skipped if all the object files are not updated.
        Then return the compile state.
        """

        # Compile all the sources and get the status
        compile_state = self.__compile_sources(self.__compiler, self.__include_string)

        link_state = None

        # Check if linking is required
        if self.__is_linking_requiered(self.__target_path, compile_state) is True:
            # If required, then link them
            link_state = self.__link_objects(
                self.__compiler,
                self.__linker_option_string,
                self.__target_path
                )
        else:
            link_state = self.LinkStatus.LINK_SKIPPED

        return self.__is_the_executable_valid(compile_state, link_state)

    def __remove_file(self, file_path:str):
        if os.path.exists(file_path):
            self.__std_output('Removing ' + file_path.replace('\\', '/'))
            os.remove(file_path)

    def clear(self):
        """
        This function removes all the object/dependency files in the object folder.
        Removes the target executable file as well.
        """
        for all_relevant_files in self.__all_relevant_file_list:
            obj_path = self.__get_directry(all_relevant_files.obj)

            # Get the list of all files in the object path
            files = glob.glob(obj_path+r'\*')

            # Remove all files in the object directly
            for file in files:
                # Remove a file
                self.__remove_file(file)
        # Remove the target file
        self.__remove_file(self.__target_path)

    def build(self)->ExecutableStatus:
        """
        This function will compile all source files in any cases.
        Then return the compile state.
        """
        # Removes all the object/dependency files in the object folder.
        self.clear()

        # Then, make
        return self.make()

if __name__ == "__main__":
    EXT_SOURCE_ADD_FROM_JSON = True
    if EXT_SOURCE_ADD_FROM_JSON is True:
        ext_instance = MakeFile()
        ext_instance.load_json_makefile('./MakefileTest/makefile.jsonc')
    else:
        EXT_TARGET = './MakefileTest/test.exe'
        EXT_COMPILER = 'gcc'
        EXT_INCLUDE_PATH = ['./MakefileTest/math']
        EXT_LINKER_OPTION = ['-MMD', '-Wall', '-O2']
        ext_instance = MakeFile(EXT_TARGET, EXT_COMPILER, EXT_INCLUDE_PATH, EXT_LINKER_OPTION)

        EXT_COMPILE_OPTION = ['-MMD', '-Wall', '-O2']
        EXT_OBJ_PATH = './MakefileTest/Obj'

        EXT_SOURCE = './MakefileTest/main.c'
        ext_instance.add_src(EXT_SOURCE, EXT_COMPILE_OPTION, EXT_OBJ_PATH)

        EXT_SOURCE = './MakefileTest/math/math.c'
        ext_instance.add_src(EXT_SOURCE, EXT_COMPILE_OPTION, EXT_OBJ_PATH)

    print('**** Output all object file to be generated ****')
    print(ext_instance.get_all_object_path())

    print('****At first invoke clear****')
    ext_instance.clear()

    print('\n****Start make test****')
    ext_instance.make()

    print('\n****Start make test second time. should be skipped all compilation****')
    ext_instance.make()

    print('\n****Start build test.****')
    ext_instance.build()

    print('\n****Start only make updated files test.****')
    TimeStampComp.ClearTimeStampDict()
    os.utime(path='./MakefileTest/math/math.h', times=None)
    ext_instance.make()
